// Copyright 2020 Tencent Inc.  All rights reserved.
//
// Author: kylau@tencent.com (Lau, Kwan Yuen)
//
// Type definitions for debugger's implementation. 

#pragma once

#pragma warning(disable: 4251)

#include <string>
#include <vector>

#include "G6ToolKitInterface.h"

// Namespace for ToolKit's build.
#ifdef DEBUG_MODULE_BUILD_WITH_TOOLKIT
namespace G6ToolKit
{
#endif // DEBUG_MODULE_BUILD_WITH_TOOLKIT

// Supported debug actions. 
enum class DebugAction
{
    kStart = 0, 
    kContinue, 
    kPause, 
    kStepOver, 
    kStepIn, 
    kStepOut, 
    kStop, 
    kUnknown
};

// Supported value scopes. 
enum class DebugScope
{
    kVariable = 0, 
    kLocal, 
    kUpvalue, 
    kGlobal
};

// Structure describing a lua breakpoint. 
class BreakPoint
{
public:
    BreakPoint(std::string file_name, int line, std::string condition = "", std::string hit_condition = "", std::string log_message = "");

    bool IsMatched(BreakPoint& other) const;

    static std::string NormalizeFilePath(const std::string& file_name);

    static bool HasSameName(const BreakPoint& lhs, const BreakPoint& rhs);

public: /* Provided from remote. */
    // Where the function was defined. 
    std::string file_name;
    // The line of the source where the function was defined. 
    int line;

    // Break when expression evaluates to true. 
    // An empty string will be ignored. 
    std::string condition;

    // Break when hit count condition is met. 
    // An empty string will be ignored. 
    std::string hit_condition;

    // Message to log when breakpoint is hit. 
    // An empty string will be ignored. 
    std::string log_message;

public: /* Computed at local. */
    // Perform fuzzy matching on each segments of path, 
    // to verify whether this breakpoint is triggered. 
    std::vector<std::string> path_segments;

    // Local hit count. 
    unsigned hit;

    // Optional file extension names. 
    // This is served for robuster matching of breakpoints. 
    static std::vector<std::string> extnames;

protected:
    BreakPoint() = delete;
};

class Variable;

// To prevent passing STL container object(s) between DLLs directly, 
// which may lead to crash(es) if DLLs' STL versions are different. 
class VariableVector
{
public:
    VariableVector() = default;

    void emplace_back(Variable* variable);
    TOOLKITCORE_API Variable* emplace_back();

    TOOLKITCORE_API Variable* at(size_t index);
    TOOLKITCORE_API size_t size() const;

    std::vector<Variable*>::iterator begin() noexcept;
    std::vector<Variable*>::iterator end() noexcept;

private:
    std::vector<Variable*> variables_;
};

class VariableString
{
public:
    VariableString() = default;

    VariableString(const std::string& rhs);
    VariableString(const std::string&& rhs);
    VariableString(const char* rhs);

    VariableString& operator=(const std::string& rhs);
    VariableString& operator=(const std::string&& rhs);
    TOOLKITCORE_API VariableString& operator=(const char* rhs);

    bool operator==(const std::string& rhs) const;
    bool operator==(const std::string&& rhs) const;

    TOOLKITCORE_API const char* c_str() const;
    TOOLKITCORE_API size_t size() const;
    
    std::string str() const;
    size_t length() const;

private:
    std::string str_;
};

class TOOLKITCORE_API Variable
{
public:
    Variable();
    ~Variable();

    // Clone a new copy of this variable. 
    Variable* Clone();

public:
    // Key. 
    VariableString name;
    int name_type;
    // Value. 
    VariableString value;
    int value_type;
    // Human-readable name of value type. 
    VariableString value_type_name;

    VariableVector children;
    // Cache id, which is generated by debugger. 
    // This field only matters if the value type is Userdata or Table. 
    // Otherwise, it is set to be 0 by default. 
    int cache_id;

    // Scope of this variable. 
    DebugScope scope;
};

typedef Variable* (*VariableAllocator)();

class Stack
{
public:
    Stack();
    ~Stack();

    // Create an empty variable. 
    Variable* CreateVariable();

public:
    // Where the function was defined. 
    std::string file_name;
    // A reasonable name for the function. 
    std::string func_name;
    // The line of the source where the function was defined. 
    int line;

    // Stack level. 
    int level;

    // Variable(s) at the current stack. 
    VariableVector local_variables;
    VariableVector upvalue_variables;
};

typedef Stack* (*StackAllocator)();

class EvalContext
{
public:
    EvalContext(std::string expr, int stack_level = 0, int depth = 0, int serial_num = 0, int cache_id = 0);

public: /* Provided from remote. */
    // Expression to be evaluated. 
    std::string expr;
    // Level of stack. 
    int stack_level;
    // Recursion depth. 
    int depth;
    // Cache id, which is generated by debugger. 
    // This field only matters if the value type is Userdata or Table. 
    // Otherwise, it is set to be 0 by default. 
    int cache_id;

public: /* Computed at local. */
    // Evaluation status. 
    bool is_success;
    std::string error;
    // Evaluation result. 
    Variable result;

public: /* Generated from remote. */
    // Serial number of request. 
    int serial_num;

protected:
    EvalContext() = delete;
};

#ifdef DEBUG_MODULE_EXPORT_C_API
extern "C"
{
    TOOLKITCORE_API const char* VariableGetName(Variable* variable);
    TOOLKITCORE_API int VariableGetNameType(Variable* variable);
    TOOLKITCORE_API const char* VariableGetValue(Variable* variable);
    TOOLKITCORE_API int VariableGetValueType(Variable* variable);
    TOOLKITCORE_API const char* VariableGetValueTypeName(Variable* variable);

    TOOLKITCORE_API void VariableSetName(Variable* variable, const char* name);
    TOOLKITCORE_API void VariableSetNameType(Variable* variable, int name_type);
    TOOLKITCORE_API void VariableSetValue(Variable* variable, const char* value);
    TOOLKITCORE_API void VariableSetValueType(Variable* variable, int value_type);
    TOOLKITCORE_API void VariableSetValueTypeName(Variable* variable, const char* value_type_name);

    TOOLKITCORE_API Variable* VariableAppendChild(Variable* variable);
}
#endif

// Namespace for ToolKit's build.
#ifdef DEBUG_MODULE_BUILD_WITH_TOOLKIT
}
#endif // DEBUG_MODULE_BUILD_WITH_TOOLKIT
